# 聊聊防抖与节流
## 参考
+ [75周刊 深入浅出防抖函数 debounce](https://mp.weixin.qq.com/s/HBx7Yl5K88maDHWR50Ua-w)
+ [深入篇 | Lodash 防抖和节流是怎么实现的](https://mp.weixin.qq.com/s/LJDc2M45HqBhTAgayZkEJQ)
+ [【文档】lodash/debounce](https://www.lodashjs.com/docs/latest#_debouncefunc-wait0-options)
+ [【文档】lodash/throttle](https://www.lodashjs.com/docs/latest#_throttlefunc-wait0-options)
+ [【源码】lodash/debounce.js](https://github.com/lodash/lodash/blob/master/debounce.js)
+ [【源码】lodash/throttle.js](https://github.com/lodash/lodash/blob/master/throttle.js)

## 大纲
<!-- + 背景 -> 一行奇怪的代码 -->
<!-- + 事件队列与setTimeout定时器 -->
+ 生活场景 -> 电梯门
+ 防抖 debounce
+ 节流 throttle
+ 优化：fn上的实现
+ loadsh、underscore中节流的实现 _.throttle _.debounce
+ 用途，onresize
+ 闭包、高阶函数、事件队列&定时器

## 背景
**灵魂3问**
1. 什么是函数防抖？
限制函数触发n秒后再执行，这段时间内，如果事件又被触发，就重新计算延迟。
酒店大厅的自动门，有人就会开启，并延迟一段时间关闭；如果有人持续进入，则会刷新这个延迟时间。
自动扶梯，有人站上去时则加速，直到无人乘坐时，速度才会降下来。
电梯，有人进入时，就不会关闭。直到无人进入一段时间后，或者按下关门键，才会执行关门。
2. 什么是节流？
节流不会重新计算延迟，而是忽略在一段时间内频繁重复触发的函数。-->  防抖是后项触发，节流是前项触发。
3. 什么时候防抖，什么时候节流？
~

![节流1](./assets/throttle1.webp)
![节流2](./assets/throttle2.webp)

**demos**
+ [防抖 debounce](https://code.h5jun.com/zedul/edit?html,js,console,output)
+ [按钮（节流）](https://code.h5jun.com/gale/1/edit?js,output)
+ [小鸟（节流）](https://code.h5jun.com/wik/3/edit?js,output)

## 防抖 debounce
```js
let debounce = (fn, timeForWait = 1000) => {
  console.log('[function: debounce] been called!')
  fn.timerId = null
  return function(){
    let args = [].slice.call(arguments)
    if (fn.timerId) {
        clearTimeout(fn.timerId)
        fn.timerId = null
    }
    fn.timerId = setTimeout(() => {
      fn(...args)
    }, timeForWait)
  }
}
```

定时器Id挂载到函数上fn.timerId VS 直接采用变量，形成闭包保存在内存中？
答：直接用闭包更好。关于网上说的，怕会互相影响，那就多次调用debounce绑定就好。如果需要互相影响，就调用同一次绑定的。
如果采用挂载到函数上的方式，因为外界可以访问到，首先，容易被篡改，打包同一个函数时，更会互相影响。

## 节流 throttle

```js
let throttle = (fn, timeForWait = 1000) => {
  console.log('[function: throttle] been called!')
  return function(){
    let args = [].slice.call(arguments)
    if(!fn.timerId){
      fn.apply(this,  args);
      fn.timerId = setTimeout(() => {
        fn.timerId = null;
      }, timeForWait)
    }
  }
}
```

## lodash 源码

```js
// 滚动懒加载
$(window).on('scroll', _.throttle(function() {
    console.log('scroll')
}, 300))
// 页面调整大小时，防止重复计算
$(window).on('resize', _.debounce(calculateLayout, 150))
```

### 控制参数
+ leading, 第一次调用是否立即执行
+ trailing, 最后一次调用是否执行
+ maxWait, 最长等待时间 (仅 debounce 有)

```js
// 用 debounce + maxWait 实现 thtottle
_.throttle = function(fn, wait, opt) {
  wait = wait || 0
  opt = _.extend({
    leading: true,
    trailing: true,
    maxWait: wait // wait 即 maxWait
  })
  return _.debounce(fn, wait, opt)
}
```

